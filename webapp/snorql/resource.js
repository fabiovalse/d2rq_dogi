// Generated by CoffeeScript 1.10.0
(function() {
  var direct, direct_table, enter_direct, enter_inverse, inverse, inverse_table, o_format, p_format;

  p_format = function(predicate) {
    return "<a href='" + predicate.uri + "' title='" + predicate.uri + "'><span class='small prefix" + (predicate.prefix === 'dogi:' ? ' dogi_prefix' : '') + "'>" + predicate.prefix + "</span><span class='suffix'>" + predicate.suffix + "</span><a>";
  };

  o_format = function(object) {
    var k, match, v;
    match = object.value.match(/(.*)\^\^(http:\/\/.*)/);
    if (match !== null) {
      return "<span class='literal'>" + match[1] + "</span> <span class='small literal' title='" + match[2] + "'>(<a target='_blank' class='datatype' href='" + match[2] + "'>" + (match[2].slice(match[2].indexOf('#') + 1)) + "</a>)</span>";
    } else if (object.isURI) {
      for (k in D2R_namespacePrefixes) {
        v = D2R_namespacePrefixes[k];
        if (object.value.indexOf(v) === 0) {
          return "<a href='" + object.value + "' title='" + object.value + "'><span class='small prefix" + (k === 'dogi' ? ' dogi_prefix' : '') + "'>" + k + ":</span><span class='suffix'>" + (object.value.slice(v.length)) + "</span><a>";
        }
      }
      return "<span class='uri'><<a href='" + object.value + "'>" + object.value + "</a>></span>";
    } else if (object.value.indexOf("http") === 0) {
      return "<span class='uri'><a href='" + object.value + "'>" + object.value + "</a></span>";
    } else {
      return "<span class='literal'>" + object.value + "</span>";
    }
  };


  /* Resource label and URI
   */

  d3.select('#header .title').html(resource.label);

  d3.select('#header .subtitle').text(resource.uri);


  /* Triples list
   */

  direct_table = d3.select('#direct');

  inverse_table = d3.select('#inverse');


  /* Direct
   */

  if (triples_data.direct.length === 0) {
    direct_table.append('tr').append('td').text('No Direct triples defined.');
  }

  triples_data.direct.sort(function(a, b) {
    if (a.type === 'Data property' && b.type === 'Data property') {
      if ((a.predicate.prefix + a.predicate.suffix) < (b.predicate.prefix + a.predicate.suffix)) {
        return -1;
      } else {
        return 1;
      }
    } else if (a.type === 'Object property' && b.type === 'Object property') {
      if ((a.predicate.prefix + a.predicate.suffix) < (b.predicate.prefix + a.predicate.suffix)) {
        return -1;
      } else {
        return 1;
      }
    } else if (a.type === 'Data property') {
      return -1;
    } else {
      return 1;
    }
  });

  direct = direct_table.selectAll('tr').data(triples_data.direct);

  enter_direct = direct.enter().append('tr');

  enter_direct.append('td').attr({
    "class": 'predicate'
  });

  enter_direct.append('td').attr({
    "class": 'object'
  });

  direct.select('.predicate').html(function(d) {
    return p_format(d.predicate);
  });

  direct.select('.object').html(function(d) {
    return o_format(d.object);
  });


  /* Inverse
   */

  if (triples_data.inverse.length === 0) {
    inverse_table.append('tr').append('td').attr({
      "class": 'literal'
    }).text('No Inverse triples defined.');
  }

  inverse = inverse_table.selectAll('tr').data(triples_data.inverse);

  enter_inverse = inverse.enter().append('tr');

  enter_inverse.append('td').attr({
    "class": 'predicate'
  });

  enter_inverse.append('td').attr({
    "class": 'object'
  });

  inverse.select('.predicate').html(function(d) {
    return p_format(d.predicate);
  });

  inverse.select('.object').html(function(d) {
    return o_format(d.object);
  });

}).call(this);
